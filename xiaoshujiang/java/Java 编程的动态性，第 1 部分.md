---
tags: Java 编程的动态性，第 1 部分
grammar_cjkRuby: true
---
2019年09月17日 14时34分06秒
# 类和类装入
研究类以及JVM装入类时所发生的情况

本文是这个新系列文章的第一部分，该系列文章将讨论Java编程的动态性的一系列主题。这些主题的范围从Java二进制类文件格式的基本结构，以及使用反射进行运行时元数据访问，一直到在运行时修改和构造新类。贯穿整篇文章的公共线索是这样一种思想：**在Java平台上编程要比直接使用编译成本机代码的语言更具动态性。** 如果您理解了这些动态方面，就可以使用Java编程完成那些在任何其它主流编程语言中不能完成的事情。

本文中，我们将讨论一些基本概念，它们是这些Java平台动态特性的基础。这些概念的核心是用于表示Java类的二进制格式，包括这些类装入到JVM时所发生的的情况。本文不仅是本系列其余几篇文章的基础，而且还演示了开发人员在使用Java平台时碰到的一些非常实际的问题。

## 用二进制表示的类

使用Java语言的开发人员在用编译器编译它们的源代码时，通常不必关心对这些源代码做了些什么样的细节。但是本系列文章中，我们将讨论从源代码到执行程序所涉及的许多幕后细节，因此我们将首先探讨由编译器生成的二进制类。

二进制类格式实际上是由JVN规范定义的。通常这些类表示是由编译器从Java语言源代码生成的，而且他们通常存储在扩展名为 **.class** 的文件中。但是，这些特性都无关紧要。已经开发了可以使用Java二进制类格式的其它一些编程语言，而且出于某些目的，还构建的新的类表示，并被立即装入到运行中的JVM。就JVM而言，重要的部分不是源代码以及如何存储源代码，而是格式本身。

那么这个类格式实际看上去是什么样呢？清单1提供了一个（非常）简短的类的源代码，还附带了有编译器输出的类文件的部分十六进制显示：

清单1. Hello.java的源代码和（部分）二进制类文件
```java
public class Hello
{
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
0000: cafe babe 0000 002e 001a 0a00 0600 0c09  ................
0010: 000d 000e 0800 0f0a 0010 0011 0700 1207  ................
0020: 0013 0100 063c 696e 6974 3e01 0003 2829  .....<init>...()
0030: 5601 0004 436f 6465 0100 046d 6169 6e01  V...Code...main.
0040: 0016 285b 4c6a 6176 612f 6c61 6e67 2f53  ..([Ljava/lang/S
0050: 7472 696e 673b 2956 0c00 0700 0807 0014  tring;)V........
0060: 0c00 1500 1601 000d 4865 6c6c 6f2c 2057  ........Hello, W
0070: 6f72 6c64 2107 0017 0c00 1800 1901 0005  orld!...........
0080: 4865 6c6c 6f01 0010 6a61 7661 2f6c 616e  Hello...java/lan
0090: 672f 4f62 6a65 6374 0100 106a 6176 612f  g/Object...java/
00a0: 6c61 6e67 2f53 7973 7465 6d01 0003 6f75  lang/System...ou
...
```

### 二进制类文件的内幕

清单1显示的二进制类表示中首先是“cafe babe”特征符，它标识Java二进制类格式（并顺便作为一个永久的 ― 但很大程度上未被认识到的 ― 礼物送给努力工作的barista，他们本着开发人员所具备的精神构建Java平台）。这个特征符恰好是一种验证一个数据块 确实声明成Java类格式的一个实例的简单方法。任何Java二进制（甚至是文件系统中没有出现的类）都需要以这四个字节作为开始。

